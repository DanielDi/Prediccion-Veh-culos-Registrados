---
title: "Agrupamiento-Universidades"
author: "Brayan M. Ortiz Fajardo, Juan Felipe Peña Tamayo, Thalea Marina Hesse, Juan Sebastián Falcon, Daniel Espinal Mosquera"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library("readxl")
library(dplyr)
library(stats)
library('simts')
library('tseries')
library("corrplot")
library("Metrics")
library("randomForest")
```
# Lectura de los datos
Los datos corresponden a la suma de los 365 días que tienen los años 2013, 2014, 2015 y 2017 sumados a los 366 días que tiene los años 2012 y 2016. En total, se tienen 2192 datos.
```{r include=FALSE}
datos <- read_excel("registros_entrenamiento_festivos.xlsx")
```

## Procesamiento de los datos

Los datos originales contienen, únicamente, una variable: La fecha de registro. Para buscar un óptimo análisis, se decidió generar 4 variables nuevas con base a la fecha de registro, estas son: día de la semana, número de día del mes, mes y año.
Además, se generó una variable binaria llamada "festivo" para conocer si un día del año es una festividad en Colombia, pues estos días suelen presentar valores atípicos en las unidades registradas y esta variable aporta esta información.

```{r, echo=FALSE}
datos$Fecha <- as.Date(datos$Fecha)
datos$Ts <- as.numeric(datos$Fecha)
datos$Dia_semana <- weekdays(datos$Fecha)

datos$Dia <- format(datos$Fecha, "%d")
datos$Mes <- as.factor(as.numeric(format(datos$Fecha, "%m")))
datos$Anio <- format(datos$Fecha, "%y")
datos$Wday <- lubridate::wday(datos$Fecha, week_start = 1)

datos <- datos[-1]
```

```{r}
plot(datos$Ts, datos$Unidades)
```
Cosas interesantes:
En semana santa (aprox por semanas de abril) los días jueves, viernes, sábado y domingo suelen haber pocos registros en todos los años.
Los días festivos entre semana suelen generar datos atípicos en los días anteriores o posteriores (además de que el día festivo como tal también suele ser atípico)
datos <- datos[-1]

```{r}
# Se convertien a numéricos todas las variables excepto el día de la semana
datos[,c(1,2,4,6, 7, 8, 9)] <- sapply(datos[,c(1,2,4,6, 7, 8, 9)], as.numeric)

# Se dive la variable día de la semana en n variables binarias
dummy <- as.data.frame(model.matrix(~ datos$Dia_semana - 1))
colnames(dummy) <- c("domingo", "lunes", "martes", "miercoles", "jueves", "viernes", "sabado")

# Se unen los dos dataframes
datos <- subset(datos, select = c(-Dia_semana))
datos <- cbind(datos, dummy)

# Se guarda una copia de los datos sin escalar
datos_se <- datos
datos[, -c(1)] <- as.data.frame(scale(datos[, -c(1)], center = TRUE, scale = TRUE))
```

# Separación de datos en entrenamiento y validación
De los 2192 se plantea usar apróximadamente el 75% de los datos para entrenamiento. Teniendo esto en cuenta, tenemos 1644 días, lo cuál equivale a apróximadamente 4.5 años; con el fin de lograr un adecuado entrenamiento para todos los días de cada año, se extenderá este conjunto de entrenamiento hasta los 5 años, es decir, los días entre 01-01-2012 hasta 31-12-2016 y utilizar los días correspondientes al año 2017 como validación.

```{r, echo=FALSE}
# df_train <- datos[datos$Anio != "17", ]
# df_val <- datos[datos$Anio == "17", ]
datos1 <- sample(2, nrow(datos),
                   replace = T,
                   prob = c(0.75, 0.25))

df_train <- datos[datos1 == 1,]
df_test <- datos[datos1 == 2,]
```

# Análisis estadístico

```{r, echo=FALSE}
corr_train = cor(df_train)
corrplot(corr_train)
```

# Modelo de regresión lineal

```{r, echo=FALSE}
glm_ <- lm(df_train$Unidades ~ ., data = df_train)
summary(glm_)
```
   
```{r, echo=FALSE}
df_test$Y_predict <- predict(glm_, newdata=df_test)
lm__mae <- mae(df_test$Unidades, df_test$Y_predict)
lm__mse <- mse(df_test$Unidades, df_test$Y_predict)
lm__rmse <- mse(df_test$Unidades, df_test$Y_predict)
paste("Error absoluto medio (MAE): ", lm__mae)
paste("Error medio cuadrado (MSE): ", lm__mse)
paste("Error cuadrático medio (RMSE): ", lm__rmse)
```

```{r}
t_modelo <- lm(Unidades ~ Ts,datos)
T_pred <- predict(t_modelo, datos)
datos$sin_trend <- datos$Unidades - T_pred

plot(datos$Ts, datos$Unidades)
lines(datos$Ts, T_pred, type="l", col = "red")
plot(datos$Ts, datos$sin_trend)
```
```{r}

seasonM <- setRefClass("seasonM", fields = list(means = "data.frame"), methods = list(
                       predict = function(input)
                       {
                           return (means$Mean[as.numeric(input$Mes)])
                       }))

mes_means <- datos %>% group_by(Mes) %>% summarize(Mean = mean(sin_trend))
s1_modelo <- new('seasonM', means = mes_means)
datos$sin_season1 <- datos$sin_trend - s1_modelo$predict(datos)



plot(datos$Ts, datos$sin_season1)
plot(mes_means)
```
```{r}
seasonW <- setRefClass("seasonW", fields = list(means = "data.frame"), methods = list(
                       predict = function(input)
                       {
                           return (means$Mean[input$Wday])
                       }))

dia_means <- datos %>% group_by(Wday) %>% summarize(Mean = mean(sin_season1))
s2_modelo <- new('seasonW', means = dia_means)
datos$sin_season2 <- datos$sin_season1 - s1_modelo$predict(datos)

plot(datos$Ts, datos$sin_season2)
plot(dia_means)
```

```{r}
acf(datos$sin_season2)
m = auto_corr(datos$Unidades, pacf = TRUE)
plot(m)
```
Resultado: p = 8 (porque tiene todo) y q = 7 
```{r}
# no funciona .... :(
R_modelo <- arma(datos$sin_season2, order= c(8,7))
predict(R_modelo)
```
Predicción final:
```{r}
predict_final <- predict(t_modelo, datos) + s1_modelo$predict(datos) + s2_modelo$predict(datos) + predict(R_modelo, datos)
```

# Random Forest

```{r}
datos_aux <- sample(2, nrow(datos_se),
                   replace = T,
                   prob = c(0.75, 0.25))

df_train_se <- datos_se[datos_aux == 1,]
df_test_se <- datos_se[datos_aux == 2,]

rf_model <- randomForest(Unidades ~ ., data=df_train, importance=TRUE, proximity=TRUE)
round(importance(rf_model), 2)
rf_model
```
```{r}
df_test_se$Y_predict <- predict(rf_model, newdata=df_test_se)
lm__mae <- mae(df_test_se$Unidades, df_test_se$Y_predict)
lm__mse <- mse(df_test_se$Unidades, df_test_se$Y_predict)
lm__rmse <- mse(df_test_se$Unidades, df_test_se$Y_predict)
paste("Error absoluto medio (MAE): ", lm__mae)
paste("Error medio cuadrado (MSE): ", lm__mse)
paste("Error cuadrático medio (RMSE): ", lm__rmse)
```



