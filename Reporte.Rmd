---
title: "Agrupamiento-Universidades"
author: "Brayan M. Ortiz Fajardo, Juan Felipe Peña Tamayo, Thalea Marina Hesse, Juan Sebastián Falcon, Daniel Espinal Mosquera"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library("readxl")
library(dplyr)
library(stats)
library('simts')
library('tseries')
```

```{r include=FALSE}
datos <- read_excel("registros_entrenamiento_festivos.xlsx")
```

Los datos originales contienen, únciamente, una variable: La fecha de registro. Para buscar un óptimo análisis, se decidió generar 4 variables nuevas con base a la fecha de registro, estas son: día de la semana, número de día del mes, mes y año.
Además, se generó una variable binaria llamada "festivo" para conocer si un día del año es una festividad en Colombia, pues estos días suelen presentar valores atípicos en las unidades registradas y esta variable aporta esta información.
```{r}
datos$Fecha <- as.Date(datos$Fecha)
datos$Ts <- as.numeric(datos$Fecha)
datos$Dia_semana <- weekdays(datos$Fecha)
datos$Dia <- format(datos$Fecha, "%d")
datos$Mes <- as.factor(as.numeric(format(datos$Fecha, "%m")))
datos$Anio <- format(datos$Fecha, "%y")
datos$Wday <- lubridate::wday(datos$Fecha, week_start = 1)

datos <- datos[-1]
```
```{r}
plot(datos$Ts, datos$Unidades)
```
Cosas interesantes:
En semana santa (aprox por semanas de abril) los días jueves, viernes, sábado y domingo suelen haber pocos registros en todos los años.
Los días festivos entre semana suelen generar datos atípicos en los días anteriores o posteriores (además de que el día festivo como tal también suele ser atípico)


```{r}
t_modelo <- lm(Unidades ~ Ts,datos)
T_pred <- predict(t_modelo, datos)
datos$sin_trend <- datos$Unidades - T_pred

plot(datos$Ts, datos$Unidades)
lines(datos$Ts, T_pred, type="l", col = "red")
plot(datos$Ts, datos$sin_trend)
```
```{r}

seasonM <- setRefClass("seasonM", fields = list(means = "data.frame"), methods = list(
                       predict = function(input)
                       {
                           return (means$Mean[as.numeric(input$Mes)])
                       }))

mes_means <- datos %>% group_by(Mes) %>% summarize(Mean = mean(sin_trend))
s1_modelo <- new('seasonM', means = mes_means)
datos$sin_season1 <- datos$sin_trend - s1_modelo$predict(datos)



plot(datos$Ts, datos$sin_season1)
plot(mes_means)
```
```{r}
seasonW <- setRefClass("seasonW", fields = list(means = "data.frame"), methods = list(
                       predict = function(input)
                       {
                           return (means$Mean[input$Wday])
                       }))

dia_means <- datos %>% group_by(Wday) %>% summarize(Mean = mean(sin_season1))
s2_modelo <- new('seasonW', means = dia_means)
datos$sin_season2 <- datos$sin_season1 - s1_modelo$predict(datos)

plot(datos$Ts, datos$sin_season2)
plot(dia_means)
```

```{r}
acf(datos$sin_season2)
m = auto_corr(datos$Unidades, pacf = TRUE)
plot(m)
```
Resultado: p = 8 (porque tiene todo) y q = 7 
```{r}
# no funciona .... :(
R_modelo <- arma(datos$sin_season2, order= c(8,7))
predict(R_modelo)
```
Predict final:
```{r}

predict_final <- predict(t_modelo, datos) + s1_modelo$predict(datos) + s2_modelo$predict(datos) + predict(R_modelo, datos)
```
